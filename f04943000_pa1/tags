!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CC	Makefile	/^CC=g++$/;"	m
CELL_H	src/cell.h	2;"	d
Cell	src/cell.h	/^    Cell(string& name, bool part, int id) :$/;"	f	class:Cell
Cell	src/cell.h	/^class Cell$/;"	c
EXECUTABLE	Makefile	/^EXECUTABLE=fm$/;"	m
INCLUDES	Makefile	/^INCLUDES=src\/cell.h src\/net.h src\/partitioner.h$/;"	m
LDFLAGS	Makefile	/^LDFLAGS=-std=c++11 -O3 -lm$/;"	m
NET_H	src/net.h	2;"	d
Net	src/net.h	/^    Net(string& name) :$/;"	f	class:Net
Net	src/net.h	/^class Net$/;"	c
Node	src/cell.h	/^    Node(const int& id) :$/;"	f	class:Node
Node	src/cell.h	/^class Node$/;"	c
OBJECTS	Makefile	/^OBJECTS=$(SOURCES:.c=.o)$/;"	m
PARTITIONER_H	src/partitioner.h	2;"	d
Partitioner	src/partitioner.h	/^    Partitioner(fstream& inFile) :$/;"	f	class:Partitioner
Partitioner	src/partitioner.h	/^class Partitioner$/;"	c
SOURCES	Makefile	/^SOURCES=src\/partitioner.cpp src\/main.cpp$/;"	m
_accGain	src/partitioner.h	/^    int                 _accGain;       \/\/ accumulative gain$/;"	m	class:Partitioner
_bFactor	src/partitioner.h	/^    double              _bFactor;       \/\/ the balance factor to be met$/;"	m	class:Partitioner
_bList	src/partitioner.h	/^    map<int, Node*>     _bList[2];      \/\/ bucket list of partition A(0) and B(1)$/;"	m	class:Partitioner
_bestMoveNum	src/partitioner.h	/^    int                 _bestMoveNum;   \/\/ store best number of movements$/;"	m	class:Partitioner
_cellArray	src/partitioner.h	/^    vector<Cell*>       _cellArray;     \/\/ cell array of the circuit$/;"	m	class:Partitioner
_cellList	src/net.h	/^    vector<int>     _cellList;      \/\/ List of cells the net is connected to$/;"	m	class:Net
_cellName2Id	src/partitioner.h	/^    map<string, int>    _cellName2Id;   \/\/ mapping from cell name to id$/;"	m	class:Partitioner
_cellNum	src/partitioner.h	/^    int                 _cellNum;       \/\/ number of cells$/;"	m	class:Partitioner
_cutSize	src/partitioner.h	/^    int                 _cutSize;       \/\/ cut size$/;"	m	class:Partitioner
_gain	src/cell.h	/^    int             _gain;      \/\/ gain of the cell$/;"	m	class:Cell
_id	src/cell.h	/^    int         _id;    \/\/ id of the node (indicating the cell)$/;"	m	class:Node
_iterNum	src/partitioner.h	/^    int                 _iterNum;       \/\/ number of iterations$/;"	m	class:Partitioner
_lock	src/cell.h	/^    bool            _lock;      \/\/ whether the cell is locked$/;"	m	class:Cell
_maxAccGain	src/partitioner.h	/^    int                 _maxAccGain;    \/\/ maximum accumulative gain$/;"	m	class:Partitioner
_maxGainCell	src/partitioner.h	/^    Node*               _maxGainCell;   \/\/ pointer to max gain cell$/;"	m	class:Partitioner
_maxPinNum	src/partitioner.h	/^    int                 _maxPinNum;     \/\/ Pmax for building bucket list$/;"	m	class:Partitioner
_moveNum	src/partitioner.h	/^    int                 _moveNum;       \/\/ number of cell movements$/;"	m	class:Partitioner
_moveStack	src/partitioner.h	/^    vector<int>         _moveStack;     \/\/ history of cell movement$/;"	m	class:Partitioner
_name	src/cell.h	/^    string          _name;      \/\/ name of the cell$/;"	m	class:Cell
_name	src/net.h	/^    string          _name;          \/\/ Name of the net$/;"	m	class:Net
_netArray	src/partitioner.h	/^    vector<Net*>        _netArray;      \/\/ net array of the circuit$/;"	m	class:Partitioner
_netList	src/cell.h	/^    vector<int>     _netList;   \/\/ list of nets the cell is connected to$/;"	m	class:Cell
_netName2Id	src/partitioner.h	/^    map<string, int>    _netName2Id;    \/\/ mapping from net name to id$/;"	m	class:Partitioner
_netNum	src/partitioner.h	/^    int                 _netNum;        \/\/ number of nets$/;"	m	class:Partitioner
_next	src/cell.h	/^    Node*       _next;  \/\/ pointer to the next node$/;"	m	class:Node
_node	src/cell.h	/^    Node*           _node;      \/\/ node used to link the cells together$/;"	m	class:Cell
_part	src/cell.h	/^    bool            _part;      \/\/ partition the cell belongs to (0-A, 1-B)$/;"	m	class:Cell
_partCount	src/net.h	/^    int             _partCount[2];  \/\/ Cell number in partition A(0) and B(1)$/;"	m	class:Net
_partSize	src/partitioner.h	/^    int                 _partSize[2];   \/\/ size (cell number) of partition A(0) and B(1)$/;"	m	class:Partitioner
_pinNum	src/cell.h	/^    int             _pinNum;    \/\/ number of pins the cell are connected to$/;"	m	class:Cell
_prev	src/cell.h	/^    Node*       _prev;  \/\/ pointer to the previous node$/;"	m	class:Node
_unlockNum	src/partitioner.h	/^    int                 _unlockNum[2];  \/\/ number of unlocked cells$/;"	m	class:Partitioner
addCell	src/net.h	/^    void addCell(const int cellId)  { _cellList.push_back(cellId); }$/;"	f	class:Net
addNet	src/cell.h	/^    void addNet(const int netId) { _netList.push_back(netId); }$/;"	f	class:Cell
changeAllGainOnNet	src/partitioner.cpp	/^void Partitioner::changeAllGainOnNet(Net* net, const bool& b)$/;"	f	class:Partitioner
changeOneGainOnNet	src/partitioner.cpp	/^void Partitioner::changeOneGainOnNet(Net* net, const bool& b, const bool& part)$/;"	f	class:Partitioner
checkBalance	src/partitioner.h	/^	bool checkBalance(){$/;"	f	class:Partitioner
clear	src/partitioner.cpp	/^void Partitioner::clear()$/;"	f	class:Partitioner
decGain	src/cell.h	/^    void decGain()      { --_gain; }$/;"	f	class:Cell
decPartCount	src/net.h	/^    void decPartCount(int part)     { --_partCount[part]; }$/;"	f	class:Net
decPinNum	src/cell.h	/^    void decPinNum()    { --_pinNum; }$/;"	f	class:Cell
deleteNode	src/partitioner.cpp	/^void Partitioner::deleteNode(Node* node)$/;"	f	class:Partitioner
getBFactor	src/partitioner.h	/^    double getBFactor() const       { return _bFactor; }$/;"	f	class:Partitioner
getCellListPtr	src/net.h	/^    vector<int>* getCellListPtr() { return &_cellList; }$/;"	f	class:Net
getCellNum	src/partitioner.h	/^    int getCellNum() const          { return _cellNum; }$/;"	f	class:Partitioner
getCutSize	src/partitioner.h	/^    int getCutSize() const          { return _cutSize; }$/;"	f	class:Partitioner
getFirstNet	src/cell.h	/^    int getFirstNet() const { return _netList[0]; }$/;"	f	class:Cell
getGain	src/cell.h	/^    int getGain() const     { return _gain; }$/;"	f	class:Cell
getId	src/cell.h	/^    int getId() const       { return _id; }$/;"	f	class:Node
getLock	src/cell.h	/^    bool getLock() const    { return _lock; }$/;"	f	class:Cell
getName	src/cell.h	/^    string getName() const  { return _name; }$/;"	f	class:Cell
getName	src/net.h	/^    string getName()           const { return _name; }$/;"	f	class:Net
getNetListPtr	src/cell.h	/^	vector<int>* getNetListPtr() { return &_netList; }$/;"	f	class:Cell
getNetNum	src/partitioner.h	/^    int getNetNum() const           { return _netNum; }$/;"	f	class:Partitioner
getNext	src/cell.h	/^    Node* getNext() const   { return _next; }$/;"	f	class:Node
getNode	src/cell.h	/^    Node* getNode() const   { return _node; }$/;"	f	class:Cell
getPart	src/cell.h	/^    bool getPart() const    { return _part; }$/;"	f	class:Cell
getPartCount	src/net.h	/^    int getPartCount(int part) const { return _partCount[part]; }$/;"	f	class:Net
getPartSize	src/partitioner.h	/^    int getPartSize(int part) const { return _partSize[part]; }$/;"	f	class:Partitioner
getPinNum	src/cell.h	/^    int getPinNum() const   { return _pinNum; }$/;"	f	class:Cell
getPrev	src/cell.h	/^    Node* getPrev() const   { return _prev; }$/;"	f	class:Node
incGain	src/cell.h	/^    void incGain()      { ++_gain; }$/;"	f	class:Cell
incPartCount	src/net.h	/^    void incPartCount(int part)     { ++_partCount[part]; }$/;"	f	class:Net
incPinNum	src/cell.h	/^    void incPinNum()    { ++_pinNum; }$/;"	f	class:Cell
initBList	src/partitioner.cpp	/^void Partitioner::initBList()$/;"	f	class:Partitioner
initParti	src/partitioner.cpp	/^void Partitioner::initParti()$/;"	f	class:Partitioner
insertNode	src/partitioner.cpp	/^void Partitioner::insertNode(Node* node)$/;"	f	class:Partitioner
lock	src/cell.h	/^    void lock()         { _lock = true; }$/;"	f	class:Cell
main	src/main.cpp	/^int main(int argc, char** argv)$/;"	f
move	src/cell.h	/^    void move()         { _part = !_part; }$/;"	f	class:Cell
parseInput	src/partitioner.cpp	/^void Partitioner::parseInput(fstream& inFile)$/;"	f	class:Partitioner
partition	src/partitioner.cpp	/^void Partitioner::partition()$/;"	f	class:Partitioner
printBList	src/partitioner.cpp	/^void Partitioner::printBList()$/;"	f	class:Partitioner
printSummary	src/partitioner.cpp	/^void Partitioner::printSummary() const$/;"	f	class:Partitioner
reportCell	src/partitioner.cpp	/^void Partitioner::reportCell() const$/;"	f	class:Partitioner
reportNet	src/partitioner.cpp	/^void Partitioner::reportNet() const$/;"	f	class:Partitioner
setBSize	src/partitioner.h	/^	void setBSize(const int& n) { _partSize[0] = _cellNum - n; _partSize[1] = n; }$/;"	f	class:Partitioner
setCutSize	src/partitioner.h	/^	void setCutSize(const int& n) { _cutSize = n; }  $/;"	f	class:Partitioner
setGain	src/cell.h	/^    void setGain(const int gain)    { _gain = gain; }$/;"	f	class:Cell
setId	src/cell.h	/^    void setId(const int& id) { _id = id; }$/;"	f	class:Node
setInitG	src/partitioner.cpp	/^void Partitioner::setInitG()$/;"	f	class:Partitioner
setMaxGainCell	src/partitioner.h	/^	void setMaxGainCell(Cell* cell) { _maxGainCell = cell->getNode(); }$/;"	f	class:Partitioner
setMaxPinNum	src/partitioner.h	/^	void setMaxPinNum(const int& n) { _maxPinNum = n; }$/;"	f	class:Partitioner
setName	src/cell.h	/^    void setName(const string name) { _name = name; }$/;"	f	class:Cell
setName	src/net.h	/^    void setName(const string name) { _name = name; }$/;"	f	class:Net
setNext	src/cell.h	/^    void setNext(Node* next)  { _next = next; }$/;"	f	class:Node
setNode	src/cell.h	/^    void setNode(Node* node)        { _node = node; }$/;"	f	class:Cell
setPart	src/cell.h	/^    void setPart(const bool part)   { _part = part; }$/;"	f	class:Cell
setPartCount	src/net.h	/^    void setPartCount(int part, const int count) { _partCount[part] = count; }$/;"	f	class:Net
setPrev	src/cell.h	/^    void setPrev(Node* prev)  { _prev = prev; }$/;"	f	class:Node
unlock	src/cell.h	/^    void unlock()       { _lock = false; }$/;"	f	class:Cell
updateGain	src/partitioner.cpp	/^void Partitioner::updateGain(Cell* baseCell)$/;"	f	class:Partitioner
updateList	src/partitioner.cpp	/^void Partitioner::updateList(Cell* baseCell)$/;"	f	class:Partitioner
writeResult	src/partitioner.cpp	/^void Partitioner::writeResult(fstream& outFile)$/;"	f	class:Partitioner
~Cell	src/cell.h	/^    ~Cell() { }$/;"	f	class:Cell
~Net	src/net.h	/^    ~Net()  { }$/;"	f	class:Net
~Node	src/cell.h	/^    ~Node() { }$/;"	f	class:Node
~Partitioner	src/partitioner.h	/^    ~Partitioner() {$/;"	f	class:Partitioner
